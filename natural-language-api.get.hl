
/*
 * HTTP GET endpoint taking natural language input, generating Hyperlambda code solving the problem,
 * and returning the result of the execution to the caller. Response time 1 to 5 seconds typically.
 */
.arguments
   instruction:string

/*
 * System instruction.
 */
.sys:@"# Objective

You are a Hyperlambda software development assistant. Your task is to generate and respond with Hyperlambda.
DO NOT generate Hyperlambda that requires authentication or authorisation.
DO NOT generate Executable Hyperlambda files or HTTP endpoints unless user EXPLICITLY asks for it!
Make sure you always return the result of your invocation to the caller."

// Helper to log exception
.code
try

   /*
    * Invoking OpenAI with Hyperlambda Generator as model, and above instruction as our system instruction.
    */
   http.post:"https://ainiro.io/magic/modules/hyperlambda-generator/chat"
      convert:true
      payload
         prompt:x:@.arguments/*/instruction
         system_message_override:x:@.sys

   // Transforming result to a lambda object.
   hyper2lambda:x:@http.post/*/content/*/result
   set-value:x:@.code
      get-value:x:@http.post/*/content/*/result

   // Checking if user is root, at which point we just execute "whatever".
   if
      auth.ticket.in-role:root
      .lambda

         // Adding lambda object to [.lambda] invocation.
         add:x:./*/.lambda
            get-nodes:x:@hyper2lambda/*

         // Executing lambda object, and returning the result.
         .lambda
         invoke:x:-
         if
            not-null:x:@invoke
            .lambda
               return:x:@invoke
         return-nodes:x:@invoke/*

   else

      /*
       * User is NOT root, so we execute the lambda object within a [whitelist],
       * to avoid anonymous users from creating potential malicious code.
       *
       * None of the whitelisted slots changes state on the server, so worst case scenario,
       * somebody might create a long lasting job, binding up a single thread and socket
       * before returning, bu that is literally the largest risk we've got with this solution,
       * even though we're technically executing arbitrary Hyperlambda code, generated by an AI.
       */

      // Adding lambda object to [whitelist] invocation.
      add:x:./*/whitelist/*/.lambda
         get-nodes:x:@hyper2lambda/*

      // Executing lambda object, and returning the result.
      whitelist
         vocabulary
            date.now
            date.format
            time
            format
            set-name
            set-value
            get-value
            get-name
            get-count
            get-nodes
            add
            insert-after
            insert-before
            math.abs
            math.add
            math.ceil
            math.cos
            math.decrement
            math.divide
            math.floor
            math.increment
            math.max
            math.min
            math.modulo
            math.multiply
            math.random
            math.round
            math.sin
            math.sqrt
            math.subtract
            strings.builder
            strings.builder.append
            strings.capitalize
            strings.concat
            strings.contains
            strings.ends-with
            strings.html-decode
            strings.html-encode
            strings.join
            strings.length
            strings.matches
            strings.regex-replace
            strings.replace
            strings.replace-not-of
            strings.split
            strings.starts-with
            strings.substring
            strings.to-lower
            strings.to-upper
            strings.trim
            strings.trim-end
            strings.trim-start
            strings.url-decode
            strings.url-encode
            response.headers.set
            response.status.set
            for-each
            if
            else-if
            else
            return
            return-nodes
            yield
            vocabulary
            html2lambda
            html2markdown
            lambda2html
            markdown2html
            xml2lambda
            lambda2xml
            json2lambda
            lambda2json
            http.get
            and
            or
            eq
            neq
            not
            mt
            lt
            mte
            lte
            get-name
            null
            not-null
            exists
            not-exists
            unwrap
            convert
         .lambda
      if
         not-null:x:@whitelist
         .lambda
            return:x:@whitelist
      return-nodes:x:@whitelist/*

.catch
   log.error:Could not generate code
      exception:x:@.arguments/*/message
      code:x:@.code
   throw:"I’m sorry, Dave. I’m afraid I can’t do that."
      public:bool:true
      status:int:400